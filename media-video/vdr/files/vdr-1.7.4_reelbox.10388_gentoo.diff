diff -Naur vdr-1.7.4.orig/config.h vdr-1.7.4/config.h
--- vdr-1.7.4.orig/config.h	2009-02-10 00:01:51.000000000 +0100
+++ vdr-1.7.4/config.h	2009-02-10 00:08:59.000000000 +0100
@@ -272,11 +272,18 @@
   void StoreSourceCaps(const char *Name);
   bool ParseSourceCaps(const char *Value);
 #endif /* SOURCECAPS */
+#ifdef USE_EHD 
+//  cSetupLine *Get(const char *Name, const char *Plugin = NULL);
+#else
   cSetupLine *Get(const char *Name, const char *Plugin = NULL);
+#endif /* EHD */
   void Store(const char *Name, const char *Value, const char *Plugin = NULL, bool AllowMultiple = false);
   void Store(const char *Name, int Value, const char *Plugin = NULL);
 public:
   // Also adjust cMenuSetup (menu.c) when adding parameters here!
+#ifdef USE_EHD
+  cSetupLine *Get(const char *Name, const char *Plugin = NULL);
+#endif /* EHD */
   int __BeginData__;
   char OSDLanguage[I18N_MAX_LOCALE_LEN];
   char OSDSkin[MaxSkinName];
diff -Naur vdr-1.7.4.orig/font.h vdr-1.7.4/font.h
--- vdr-1.7.4.orig/font.h	2009-02-10 00:01:51.000000000 +0100
+++ vdr-1.7.4/font.h	2009-02-10 00:12:39.000000000 +0100
@@ -36,6 +36,14 @@
 private:
   static cFont *fonts[];
 public:
+#ifdef USE_EHD
+  enum { NUMCHARS = 256 };
+  typedef uint32_t tPixelData;
+  struct tCharData {
+   tPixelData width, height;
+   tPixelData lines[1];
+  };
+#endif /* EHD */
   virtual ~cFont() {}
   virtual int Width(uint c) const = 0;
           ///< Returns the width of the given character in pixel.
diff -Naur vdr-1.7.4.orig/Make.config.template vdr-1.7.4/Make.config.template
--- vdr-1.7.4.orig/Make.config.template	2009-02-10 00:01:51.000000000 +0100
+++ vdr-1.7.4/Make.config.template	2009-02-10 01:03:52.000000000 +0100
@@ -93,6 +93,7 @@
 #VOLCTRL = 1
 WAREAGLEICON = 1
 #YAEPG = 1
+#EHD = 1
 
 ### You don't need to touch the following:
 
@@ -271,3 +272,7 @@
 ifdef YAEPG
 DEFINES += -DUSE_YAEPG
 endif
+
+ifdef EHD
+DEFINES += -DUSE_EHD
+endif
\ Kein Zeilenumbruch am Dateiende.
diff -Naur vdr-1.7.4.orig/osdbase.h vdr-1.7.4/osdbase.h
--- vdr-1.7.4.orig/osdbase.h	2009-02-10 00:01:51.000000000 +0100
+++ vdr-1.7.4/osdbase.h	2009-02-10 00:16:17.000000000 +0100
@@ -98,9 +98,13 @@
 
 class cOsdMenu : public cOsdObject, public cList<cOsdItem> {
 private:
+#ifdef USE_EHD
+  static int displayMenuCount;
+#else
   static cSkinDisplayMenu *displayMenu;
   static int displayMenuCount;
   static int displayMenuItems;
+#endif /* EHD */
   char *title;
   int cols[cSkinDisplayMenu::MaxTabs];
   int first, current, marked;
@@ -115,6 +119,9 @@
 #endif /* LIEMIKUUTIO */
 protected:
   void SetDisplayMenu(void);
+#ifdef USE_EHD
+  static int displayMenuItems;
+#endif /* EHD */
   cSkinDisplayMenu *DisplayMenu(void) { return displayMenu; }
   const char *hk(const char *s);
   void SetCols(int c0, int c1 = 0, int c2 = 0, int c3 = 0, int c4 = 0);
@@ -141,6 +148,9 @@
 public:
   cOsdMenu(const char *Title, int c0 = 0, int c1 = 0, int c2 = 0, int c3 = 0, int c4 = 0);
   virtual ~cOsdMenu();
+#ifdef USE_EHD
+  static cSkinDisplayMenu *displayMenu;
+#endif /* EHD */
   virtual bool NeedsFastResponse(void) { return subMenu ? subMenu->NeedsFastResponse() : cOsdObject::NeedsFastResponse(); }
   int Current(void) const { return current; }
   void Add(cOsdItem *Item, bool Current = false, cOsdItem *After = NULL);
diff -Naur vdr-1.7.4.orig/osd.c vdr-1.7.4/osd.c
--- vdr-1.7.4.orig/osd.c	2009-02-10 00:01:51.000000000 +0100
+++ vdr-1.7.4/osd.c	2009-02-10 00:43:17.000000000 +0100
@@ -379,13 +379,20 @@
               if (strncmp(Xpm[i + 1], s, c) == 0) {
                  if (i == NoneColorIndex)
                     NoneColorIndex = MAXNUMCOLORS;
+#ifdef USE_EHD
+				 SetIndexFast(x, y, (IgnoreNone && i > NoneColorIndex) ? i - 1 : i);
+#else
                  SetIndex(x, y, (IgnoreNone && i > NoneColorIndex) ? i - 1 : i);
+#endif /* EHD */
                  break;
                  }
               }
           s += c;
           }
       }
+#ifdef USE_EHD
+  UpdateDirty(0,0,w-1,h-1);
+#endif /* EHD */
   if (NoneColorIndex < MAXNUMCOLORS && !IgnoreNone)
      return SetXpm(Xpm, true);
   return true;
@@ -415,6 +422,86 @@
 }
 
 void cBitmap::DrawBitmap(int x, int y, const cBitmap &Bitmap, tColor ColorFg, tColor ColorBg, bool ReplacePalette, bool Overlay)
+#ifdef USE_EHD
+  {
+    if (bitmap && Bitmap.bitmap && Intersects(x, y, x + Bitmap.Width() - 1, y + Bitmap.Height() - 1)) {
+      if (Covers(x, y, x + Bitmap.Width() - 1, y + Bitmap.Height() - 1))
+          Reset();
+      x -= x0;
+      y -= y0;
+      if (ReplacePalette && Covers(x + x0, y + y0, x + x0 + Bitmap.Width() - 1, y + y0 + Bitmap.Height() - 1)) {
+          Replace(Bitmap);
+          for (int iy = 0; iy < Bitmap.height; iy++) {
+              const int lineStart = Bitmap.width * iy;
+              for (int ix = 0; ix < Bitmap.width; ix++) {
+                  if (!Overlay || Bitmap.bitmap[lineStart + ix] != 0)
+                  SetIndexFast(x + ix, y + iy, Bitmap.bitmap[lineStart + ix]);
+              }
+          }
+     }
+      else {
+         tIndexes Indexes;
+         Take(Bitmap, &Indexes, ColorFg, ColorBg);
+         for (int iy = 0; iy < Bitmap.height; iy++) {
+            const int lineStart = Bitmap.width * iy;
+            for (int ix = 0; ix < Bitmap.width; ix++) {
+               //SetIndex(x + ix, y + iy, Indexes[int(Bitmap.bitmap[lineStart + ix])]);
+               SetIndexFast(x + ix, y + iy, Indexes[int(Bitmap.bitmap[lineStart + ix])]);
+            }
+         }
+      }
+      UpdateDirty(x,y,x+Bitmap.Width()-1,y+Bitmap.height-1);
+    }
+}
+
+void cBitmap::DrawBitmapHor(int x, int y, int w, const cBitmap &Bitmap)
+{
+    if (bitmap && Bitmap.bitmap && Intersects(x, y, x + Bitmap.Width() - 1, y + Bitmap.Height() - 1))
+    {
+        if (Covers(x, y, x + Bitmap.Width() - 1, y + Bitmap.Height() - 1))
+        {
+            Reset();
+        }
+        x -= x0;
+        y -= y0;
+        tIndexes Indexes;
+        Take(Bitmap, &Indexes, 0, 0);
+        for (int iy = 0; iy < Bitmap.height; iy++)
+        {
+            tIndex index = Indexes[int(Bitmap.bitmap[iy])];
+            for (int ix = 0; ix < w; ix++)
+            {
+                SetIndexFast(x + ix, y + iy, index);
+            }
+        }
+    }
+    UpdateDirty(x,y,x+w-1,y+Bitmap.height-1);
+}
+
+void cBitmap::DrawBitmapVert(int x, int y, int h, const cBitmap &Bitmap)
+{
+    if (bitmap && Bitmap.bitmap && Intersects(x, y, x + Bitmap.Width() - 1, y + Bitmap.Height() - 1))
+    {
+        if (Covers(x, y, x + Bitmap.Width() - 1, y + Bitmap.Height() - 1))
+        {
+            Reset();
+        }
+        x -= x0;
+        y -= y0;
+         tIndexes Indexes;
+        Take(Bitmap, &Indexes, 0, 0);
+        for (int ix = 0; ix < Bitmap.width; ix++)
+        {
+            tIndex index = Indexes[int(Bitmap.bitmap[ix])];
+            for (int iy = 0; iy < h; iy++)
+            {
+                SetIndexFast(x + ix, y + iy, index);
+             }
+		}
+    }
+    UpdateDirty(x,y,x+Bitmap.width-1,y+h-1);
+ }
+#else
 {
   if (bitmap && Bitmap.bitmap && Intersects(x, y, x + Bitmap.Width() - 1, y + Bitmap.Height() - 1)) {
      if (Covers(x, y, x + Bitmap.Width() - 1, y + Bitmap.Height() - 1))
@@ -442,7 +529,7 @@
         }
      }
 }
-
+#endif /* EHD */
 void cBitmap::DrawText(int x, int y, const char *s, tColor ColorFg, tColor ColorBg, const cFont *Font, int Width, int Height, int Alignment)
 {
   if (bitmap) {
@@ -502,10 +589,55 @@
      x2 = min(x2, width - 1);
      y2 = min(y2, height - 1);
      tIndex c = Index(Color);
+#ifdef USE_EHD
+     if (dirtyX1 > x1)  dirtyX1 = x1;
+     if (dirtyY1 > y1)  dirtyY1 = y1;
+     if (dirtyX2 < x2)  dirtyX2 = x2;
+     if (dirtyY2 < y2)  dirtyY2 = y2;
+
+       for (int y = y1; y <= y2; y++)
+       {
+           if (x2 >= x1)
+           {
+               memset(bitmap + y * width + x1, c, x2 - x1 + 1);
+           }
+           //for (int x = x1; x <= x2; x++)
+           //    SetIndex(x, y, c);
+       }
+    }
+}
+
+void cBitmap::DrawRectangle(int x1, int y1, int x2, int y2, tColor Color, int alphaGradH, int alphaGradV, int alphaGradStepH, int alphaGradStepV)
+{
+    if (bitmap && Intersects(x1, y1, x2, y2)) {
+        if (Covers(x1, y1, x2, y2))
+            Reset();
+        x1 -= x0;
+        y1 -= y0;
+        x2 -= x0;
+        y2 -= y0;
+        x1 = max(x1, 0);
+        y1 = max(y1, 0);
+        x2 = min(x2, width - 1);
+        y2 = min(y2, height - 1);
+        tIndex c = Index(Color);
+        if (dirtyX1 > x1)  dirtyX1 = x1;
+        if (dirtyY1 > y1)  dirtyY1 = y1;
+        if (dirtyX2 < x2)  dirtyX2 = x2;
+        if (dirtyY2 < y2)  dirtyY2 = y2;
+
+        for (int y = y1; y <= y2; y++)
+        {
+            for (int x = x1; x <= x2; x++)
+                SetIndex(x, y, c);
+        }
+    }
+#else
      for (int y = y1; y <= y2; y++)
          for (int x = x1; x <= x2; x++)
              SetIndex(x, y, c);
      }
+#endif /* EHD */	 
 }
 
 void cBitmap::DrawEllipse(int x1, int y1, int x2, int y2, tColor Color, int Quadrants)
@@ -850,7 +982,20 @@
   for (int i = 0; i < numBitmaps; i++)
       bitmaps[i]->DrawBitmap(x, y, Bitmap, ColorFg, ColorBg, ReplacePalette, Overlay);
 }
+#ifdef USE_EHD
+void cOsd::DrawBitmapHor(int x, int y, int w, const cBitmap &Bitmap)
+{
+  for (int i = 0; i < numBitmaps; i++)
+      bitmaps[i]->DrawBitmapHor(x, y, w, Bitmap);
+}
 
+void cOsd::DrawBitmapVert(int x, int y, int h, const cBitmap &Bitmap)
+{
+  for (int i = 0; i < numBitmaps; i++)
+      bitmaps[i]->DrawBitmapVert(x, y, h, Bitmap);
+}
+
+#endif /* EHD */
 void cOsd::DrawText(int x, int y, const char *s, tColor ColorFg, tColor ColorBg, const cFont *Font, int Width, int Height, int Alignment)
 {
   for (int i = 0; i < numBitmaps; i++)
@@ -863,6 +1008,13 @@
       bitmaps[i]->DrawRectangle(x1, y1, x2, y2, Color);
 }
 
+#ifdef USE_EHD
+void cOsd::DrawRectangle(int x1, int y1, int x2, int y2, tColor Color, int alphaGradH, int alphaGradV, int alphaGradStepH, int alphaGradStepV)
+{
+  for (int i = 0; i < numBitmaps; i++)
+      bitmaps[i]->DrawRectangle(x1, y1, x2, y2, Color, alphaGradH, alphaGradV, alphaGradStepH, alphaGradStepV);
+}
+#endif /* EHD */
 void cOsd::DrawEllipse(int x1, int y1, int x2, int y2, tColor Color, int Quadrants)
 {
   for (int i = 0; i < numBitmaps; i++)
@@ -875,6 +1027,18 @@
       bitmaps[i]->DrawSlope(x1, y1, x2, y2, Color, Type);
 }
 
+#ifdef USE_EHD
+void cOsd::DrawImage(u_int imageId, int x, int y, bool blend, int horRepeat, int vertRepeat) // GT: True color support.
+{
+    // No implementation.
+}
+
+void cOsd::SetImagePath(u_int imageId, char const *path) // GT: True color support.
+{
+    // No implementation.
+}
+
+#endif /* EHD */
 void cOsd::Flush(void)
 {
 }
@@ -893,6 +1057,12 @@
 {
   osdProvider = NULL;
 }
+#ifdef USE_EHD
+cOsd *cOsdProvider::CreateTrueColorOsd(int Left, int Top, uint Level) // GT: True color support.
+{
+    return CreateOsd(Left, Top, Level);
+}
+#endif /* EHD */ 
 
 cOsd *cOsdProvider::NewOsd(int Left, int Top, uint Level)
 {
@@ -913,6 +1083,33 @@
   return new cOsd(Left, Top, 999); // create a dummy cOsd, so that access won't result in a segfault
 }
 
+#ifdef USE_EHD
+//cOsd *cOsdProvider::NewTrueColorOsd(int Left, int Top, bool dontHide) // GT: True color osd support.
+cOsd *cOsdProvider::NewTrueColorOsd(int Left, int Top, int Random, uint Level, bool dontHide) // GT: True color osd support.
+{
+    if (Random) {
+   //  Left+=(rand()%Random)-(Random/2);
+   //  Top+=(rand()%Random)-(Random/2);
+   Left+=(rand()%10)-(10/2);
+   Top+=(rand()%20)-(20/2);
+    }
+  if (Level == OSD_LEVEL_DEFAULT && cOsd::IsOpen())
+     esyslog("ERROR: attempt to open OSD while it is already open - using dummy OSD!");
+  else if (osdProvider) {
+    cOsd *ActiveOsd = cOsd::Osds.Size() ? cOsd::Osds[0] : NULL;
+    cOsd *Osd = osdProvider->CreateTrueColorOsd(Left, Top, Level);
+     if (Osd == cOsd::Osds[0]) {
+        if (ActiveOsd)
+           ActiveOsd->SetActive(false);
+        Osd->SetActive(true);
+        }
+     return Osd;
+     }
+  else
+     esyslog("ERROR: no OSD provider available - using dummy OSD!");
+  return new cOsd(Left, Top, 999); // create a dummy cOsd, so that access won't result in a segfault
+}
+#endif /* EHD */
 void cOsdProvider::Shutdown(void)
 {
   delete osdProvider;
diff -Naur vdr-1.7.4.orig/osd.h vdr-1.7.4/osd.h
--- vdr-1.7.4.orig/osd.h	2009-02-10 00:01:51.000000000 +0100
+++ vdr-1.7.4/osd.h	2009-02-10 01:01:06.000000000 +0100
@@ -26,6 +26,9 @@
                    //AARRGGBB
   clrTransparent = 0x00000000,
   clrGray50      = 0x7F000000, // 50% gray
+#ifdef USE_EHD
+  clrGray62      = 0xA0000000, // 62% gray
+#endif /* EHD */
   clrBlack       = 0xFF000000,
   clrRed         = 0xFFFC1414,
   clrGreen       = 0xFF24FC24,
@@ -155,6 +158,17 @@
        ///< contents of the bitmap will be lost. If Width and Height are the same
        ///< as the current values, nothing will happen and the bitmap remains
        ///< unchanged.
+#ifdef USE_EHD
+  inline void SetSizeWithoutRealloc(int Width, int Height)
+  {
+    width = Width;
+    height = Height;
+    dirtyX1 = 0;
+    dirtyY1 = 0;
+    dirtyX2 = width - 1;
+    dirtyY2 = height - 1;
+  }
+#endif /* EHD */
   bool Contains(int x, int y) const;
        ///< Returns true if this bitmap contains the point (x, y).
   bool Covers(int x1, int y1, int x2, int y2) const;
@@ -184,6 +198,27 @@
   void SetIndex(int x, int y, tIndex Index);
        ///< Sets the index at the given coordinates to Index.
        ///< Coordinates are relative to the bitmap's origin.
+#ifdef USE_EHD
+  //void inline SetIndexFast(int x, int y, tIndex Index)
+  inline void SetIndexFast(int x, int y, tIndex Index)
+  {
+     if (bitmap) {
+         if (0 <= x && x < width && 0 <= y && y < height) {
+             bitmap[width * y + x] = Index;
+         }
+     }
+  };
+       ///< Sets the index at the given coordinates to Index.
+       ///< Coordinates are relative to the bitmap's origin. Does not update dirty-area.
+  void UpdateDirty(int x1, int y1, int x2, int y2)
+  {
+     if (dirtyX1 > x1)  dirtyX1 = x1;
+     if (dirtyY1 > y1)  dirtyY1 = y1;
+     if (dirtyX2 < x2)  dirtyX2 = x2;
+     if (dirtyY2 < y2)  dirtyY2 = y2;
+  }
+
+#endif /* EHD */
   void DrawPixel(int x, int y, tColor Color);
        ///< Sets the pixel at the given coordinates to the given Color, which is
        ///< a full 32 bit ARGB value.
@@ -198,6 +233,12 @@
        ///< area shall have its palette replaced with the one from Bitmap.
        ///< If Overlay is true, any pixel in Bitmap that has color index 0 will
        ///< not overwrite the corresponding pixel in the target area.
+#ifdef USE_EHD
+
+  void DrawBitmapHor(int x, int y, int w, const cBitmap &Bitmap);
+  void DrawBitmapVert(int x, int y, int h, const cBitmap &Bitmap);
+
+#endif /* EHD */
   void DrawText(int x, int y, const char *s, tColor ColorFg, tColor ColorBg, const cFont *Font, int Width = 0, int Height = 0, int Alignment = taDefault);
        ///< Draws the given string at coordinates (x, y) with the given foreground
        ///< and background color and font. If Width and Height are given, the text
@@ -209,6 +250,15 @@
        ///< (x2, y2) corners with the given Color. If the rectangle covers the entire
        ///< bitmap area, the color palette will be reset, so that new colors can be
        ///< used for drawing.
+#ifdef USE_EHD
+  void DrawRectangle(int x1, int y1, int x2, int y2, tColor Color, int alphaGradH, int alphaGradV, int alphaGradStepH, int alphaGradStepV); //TB
+       ///< Draws a filled rectangle defined by the upper left (x1, y1) and lower right
+       ///< (x2, y2) corners with the given Color. If the rectangle covers the entire
+       ///< bitmap area, the color palette will be reset, so that new colors can be
+       ///< used for drawing.
+       ///< //TB: The Alpha-Value is incremented all alphaGradStepH pixels by the value AlphaGradH in every line,
+       ///< and all alphaGradStepV pixels by the value alphaGradV in every row.
+#endif /* EHD */
   void DrawEllipse(int x1, int y1, int x2, int y2, tColor Color, int Quadrants = 0);
        ///< Draws a filled ellipse defined by the upper left (x1, y1) and lower right
        ///< (x2, y2) corners with the given Color. Quadrants controls which parts of
@@ -266,7 +316,11 @@
   cBitmap *savedRegion;
   cBitmap *bitmaps[MAXOSDAREAS];
   int numBitmaps;
+#ifdef USE_EHD
+//  int left, top, width, height;
+#else
   int left, top, width, height;
+#endif /* EHD */
   uint level;
   bool active;
 protected:
@@ -322,7 +376,11 @@
        ///< a single color combination, and may not be able to serve all
        ///< requested colors. By default the palette assumes there will be
        ///< 10 fixed colors and 10 color combinations.
+#ifdef USE_EHD
+  virtual cBitmap *GetBitmap(int Area);
+#else
   cBitmap *GetBitmap(int Area);
+#endif /* EHD */
        ///< Returns a pointer to the bitmap for the given Area, or NULL if no
        ///< such bitmap exists.
   virtual eOsdError CanHandleAreas(const tArea *Areas, int NumAreas);
@@ -367,15 +425,30 @@
        ///< area shall have its palette replaced with the one from Bitmap.
        ///< If Overlay is true, any pixel in Bitmap that has color index 0 will
        ///< not overwrite the corresponding pixel in the target area.
+#ifdef USE_EHD
+  virtual void DrawBitmapHor(int x, int y, int w, const cBitmap &Bitmap);
+  virtual void DrawBitmapVert(int x, int y, int h, const cBitmap &Bitmap);
+#endif /* EHD */
   virtual void DrawText(int x, int y, const char *s, tColor ColorFg, tColor ColorBg, const cFont *Font, int Width = 0, int Height = 0, int Alignment = taDefault);
        ///< Draws the given string at coordinates (x, y) with the given foreground
        ///< and background color and font. If Width and Height are given, the text
        ///< will be drawn into a rectangle with the given size and the given
        ///< Alignment (default is top-left). If ColorBg is clrTransparent, no
        ///< background pixels will be drawn, which allows drawing "transparent" text.
+#ifdef USE_EHD
+  virtual void DrawImage(u_int imageId, int x, int y, bool blend, int horRepeat = 1, int vertRepeat = 1); // GT: True color support.
+       ///< Draws a 32-Bit true color image at (x, y) (upper left).
+#endif /* EHD */
   virtual void DrawRectangle(int x1, int y1, int x2, int y2, tColor Color);
        ///< Draws a filled rectangle defined by the upper left (x1, y1) and lower right
        ///< (x2, y2) corners with the given Color.
+#ifdef USE_EHD
+  virtual void DrawRectangle(int x1, int y1, int x2, int y2, tColor Color, int alphaGradH, int alphaGradV, int alphaGradStepH, int alphaGradStepV); //TB
+       ///< Draws a filled rectangle defined by the upper left (x1, y1) and lower right
+       ///< (x2, y2) corners with the given Color.
+       ///< //TB: The Alpha-Value is incremented all alphaGradStepH pixels by the value AlphaGradH in every line,
+       ///< and all alphaGradStepV pixels by the value alphaGradV in every row.
+#endif /* EHD */
   virtual void DrawEllipse(int x1, int y1, int x2, int y2, tColor Color, int Quadrants = 0);
        ///< Draws a filled ellipse defined by the upper left (x1, y1) and lower right
        ///< (x2, y2) corners with the given Color. Quadrants controls which parts of
@@ -400,6 +473,11 @@
        ///< 7: vertical,   falling, upper
   virtual void Flush(void);
        ///< Actually commits all data to the OSD hardware.
+#ifdef USE_EHD
+  virtual void SetImagePath(u_int imageId, char const *path); // GT: True color support.
+       ///< Set the path of an image to be user later with DrawImage().
+  tArea vidWin;
+#endif /* EHD */
 #ifdef USE_PINPLUGIN
   static bool pinValid;
 #endif /* PINPLUGIN */
@@ -415,6 +493,9 @@
   virtual cOsd *CreateOsd(int Left, int Top, uint Level) = 0;
       ///< Returns a pointer to a newly created cOsd object, which will be located
       ///< at the given coordinates.
+#ifdef USE_EHD
+  virtual cOsd *CreateTrueColorOsd(int Left, int Top, uint Level); // GT: True color support.
+#endif /* EHD */
 public:
   cOsdProvider(void);
       //XXX maybe parameter to make this one "sticky"??? (frame-buffer etc.)
@@ -425,6 +506,10 @@
       ///< caller must delete it. If the OSD is already in use, or there is no OSD
       ///< provider, a dummy OSD is returned so that the caller may always use the
       ///< returned pointer without having to check it every time it is accessed.
+#ifdef USE_EHD
+  //static cOsd *NewTrueColorOsd(int Left, int Top, bool dontHide = false); // GT: True color osd support.
+  static cOsd *NewTrueColorOsd(int Left, int Top, int Random, uint Level = OSD_LEVEL_DEFAULT, bool dontHide = false); // GT: True color osd support.
+#endif /* EHD */
   static void Shutdown(void);
       ///< Shuts down the OSD provider facility by deleting the current OSD provider.
   };
diff -Naur vdr-1.7.4.orig/device.c vdr-1.7.4/device.c
--- vdr-1.7.4.orig/device.c	2009-02-10 03:49:39.000000000 +0100
+++ vdr-1.7.4/device.c	2009-02-10 03:53:28.000000000 +0100
@@ -1542,8 +1542,14 @@
   if (!dvbSubtitleConverter)
      dvbSubtitleConverter = new cDvbSubtitleConverter;
   tsToPesSubtitle.PutTs(Data, Length);
+#ifdef USE_EHD
+  int l;
+  if (const uchar *p = tsToPesSubtitle.GetPes(l)) {
+     dvbSubtitleConverter->Convert(p, l);
+#else
   if (const uchar *p = tsToPesSubtitle.GetPes(Length)) {
      dvbSubtitleConverter->Convert(p, Length);
+#endif /* EHD */
      tsToPesSubtitle.Reset();
      }
   return Length;
diff -Naur vdr-1.7.4.orig/osd.h vdr-1.7.4/osd.h
--- vdr-1.7.4.orig/osd.h	2009-02-10 04:07:30.000000000 +0100
+++ vdr-1.7.4/osd.h	2009-02-10 04:09:45.000000000 +0100
@@ -351,6 +351,9 @@
 public:
   virtual ~cOsd();
        ///< Shuts down the OSD.
+#ifdef USE_EHD
+  int left, top, width, height;
+#endif /* EHD */
   static int OsdLeft(void) { return osdLeft ? osdLeft : Setup.OSDLeft; }
   static int OsdTop(void) { return osdTop ? osdTop : Setup.OSDTop; }
   static int OsdWidth(void) { return osdWidth ? osdWidth : Setup.OSDWidth; }
